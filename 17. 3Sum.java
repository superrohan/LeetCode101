/*
Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.

Notice that the solution set must not contain duplicate triplets.

Example 1:

Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
Example 2:

Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
Example 3:

Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.
*/

/*
The two-pointers approach is more efficient. By sorting the array and using two pointers, we reduce the time complexity significantly.

Intuition:
First, sort the array. This helps in avoiding duplicates and allows the use of two pointers.
Iterate through the sorted array with an index i.
For each i, initialize two pointers: left at i+1 and right at the end of the array.
Calculate the sum of the elements at i, left, and right.
If the sum is zero, add the triplet to the results and move both pointers inward, skipping duplicates.
If the sum is less than zero, move the left pointer to increase the sum.
If the sum is greater than zero, move the right pointer to decrease the sum.
*/

class ThreeSum {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums); // Sort the array first
        
        for (int i = 0; i < nums.length - 2; i++) {
            // To avoid duplicates
            if (i == 0 || nums[i] != nums[i - 1]) {
                int left = i + 1, right = nums.length - 1;
                while (left < right) {
                    int sum = nums[i] + nums[left] + nums[right];
                    if (sum == 0) {
                        result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                        // Skip duplicates for `left` and `right`
                        while (left < right && nums[left] == nums[left + 1]) left++;
                        while (left < right && nums[right] == nums[right - 1]) right--;
                        left++;
                        right--;
                    } else if (sum < 0) {
                        left++;
                    } else {
                        right--;
                    }
                }
            }
        }
        return result;
    }
}

/*
Time Complexity: O(n^2) - Sorting the array is O(n log n), and the two-pointers approach takes O(n^2).
Space Complexity: O(1) - No additional space is used other than the output list.
*/
